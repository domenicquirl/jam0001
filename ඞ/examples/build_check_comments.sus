
fn get_ast(path) {
    print("Parsing Source File '", arg, "'");
    let input = read(arg);
    if input.class == "Error" {
        print("Error reading source file: ", input.msg);
    }
    let ast = parse(input, arg);
    if ast.class == "Error" {
        print("Parse error: ", ast.msg);
    }
    return ast;
}

fn build(args) {
    for arg in args {
        let ast = get_ast(arg);
        print("Checking comments of '", arg, "'");
        for elem in ast.elements {
            check_comments(ref elem, ref ast);
        }
        print("Executing Source File '", arg, "'");
        eval(ast);
    }
}

let trace_next_fn = false;

fn check_comments(ast, parent) {
    if trace_next_fn && ast.class != "ASTFnDef" {
        trace_next_fn = false;
    }
    if ast.class == "ASTComment" {
        for word in ast.text.split() {
            if word.starts_with("@") {
                if word.contains("todo") || word.contains("fixme") {
                    print("Warning: unresolved `", word, "`: '", ast.text, "'");
                } else if word.contains("trace") {
                    trace_next_fn = true;
                }
            }
        }
    } else if ast.class == "ASTFnDef" {
        if trace_next_fn {
            trace_next_fn = false;
            let new_body = [];
            for param in ast.params {
                new_body.add( ASTFnCall {
                    name: "print",
                    args: [ 
                        ASTStringLiteral { text: "Calling fn `" }, 
                        ASTStringLiteral { text: ast.name }, 
                        ASTStringLiteral { text: "` with " }, 
                        ASTStringLiteral { text: param }, 
                        ASTStringLiteral { text: " = " }, 
                        ASTIdent { name: param } 
                    ]
                });
            }
            for stmt in ast.body {
                new_body.add(stmt);
            }
            ast.body = new_body;
        }
        for stmt in ast.body {
            check_comments(ref stmt, ref ast);
        }
    } else if ast.class == "ASTIfStmt" {
        for stmt in ast.body {
            check_comments(ref stmt, ref ast);
        }
        for e in ast.elses {
            check_comments(ref e, ref parent);
        }
    } else if ast.class == "ASTForLoop" {
        for stmt in ast.body {
            check_comments(ref stmt, ref ast);
        }
    } else if ast.class == "ASTLetStmt" {
        check_comments(ref ast.value, ref ast);
    } else if ast.class == "ASTBinaryExpr" {
        check_comments(ref ast.lhs, ref ast);
        check_comments(ast.rhs, ast);
    }
}